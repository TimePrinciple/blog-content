---
date: 2024-02-23
---

## VFS

### File System Types Object

The filesystems are structures in the view of Linux kernel:

```c
struct file_system_type {
    // the name of the filesystem type, possible values are
    // "ext2", "ext4", "iso9660", "msdos" and etc.
    const char *name;
    // various flags (e.g. FS_REQUIRES_DEV, FS_NO_DCACHE, etc.)
    int fs_flags;
    // Initialize `struct fs_context` `->ops` and `->fs_private`
    // fields with filesystem-specific data.
    int (*init_fs_context)(struct fs_context *);
    // pointer to the array of filesystem parameters descriptors
    // `struct fs_parameter_spec`. Relate to Mount API.
    const struct fs_parameter_spec *parameters;
    // the method to call when a new instance of this filesystem
    // should be mounted !!!
    struct dentry *(*mount) (struct file_system_type *, int,
            const char *, void *);
    // the method to call when an instance of this filesystem
    // should be shutdown
    void (*kill_sb) (struct super_block *);
    // for internal VFS use, initialize to THIS_MODULE mostly
    struct module *owner;
    // for internal VFS use, initialize to NULL
    struct file_system_type * next;
    // for internal VFS use, hlist of filesystem instances 
    // (superblocks)
    struct hlist_head fs_supers;

    struct lock_class_key s_lock_key;
    struct lock_class_key s_umount_key;
    struct lock_class_key s_vfs_rename_key;
    struct lock_class_key s_writers_key[SB_FREEZE_LEVELS];

    struct lock_class_key i_lock_key;
    struct lock_class_key i_mutex_key;
    struct lock_class_key invalidate_lock_key;
    struct lock_class_key i_mutex_dir_key;
};
```

### Super Block Object

A superblock object represents a **mounted** filesystem. Its definition is:

```c
struct super_operations {
    // this method is called by `alloc_inode()` to allocate
    // memory for `struct inode` and initialize it. If this
    // function not defined, a simple `struct inode` is
    // allocated. Normally `alloc_inode` will be used to
    // allocate a larger structure which contains a
    // `struct inode` embedded within it
    struct inode *(*alloc_inode)(struct super_block *sb);
    // this method is called by `destroy_inode()` to
    // release resources allocated for `struct inode`. It
    // is only required if `->alloc_inode` was defined and
    // simple undoes anything done by `->alloc_inode`
    void (*destroy_inode)(struct inode *);
    void (*free_inode)(struct inode *);

    void (*dirty_inode) (struct inode *, int flags);
    int (*write_inode) (struct inode *, struct writeback_control *wbc);
    int (*drop_inode) (struct inode *);
    void (*evict_inode) (struct inode *);
    void (*put_super) (struct super_block *);
    int (*sync_fs)(struct super_block *sb, int wait);
    int (*freeze_super) (struct super_block *sb,
                            enum freeze_holder who);
    int (*freeze_fs) (struct super_block *);
    int (*thaw_super) (struct super_block *sb,
                            enum freeze_wholder who);
    int (*unfreeze_fs) (struct super_block *);
    int (*statfs) (struct dentry *, struct kstatfs *);
    int (*remount_fs) (struct super_block *, int *, char *);
    void (*umount_begin) (struct super_block *);

    int (*show_options)(struct seq_file *, struct dentry *);
    int (*show_devname)(struct seq_file *, struct dentry *);
    int (*show_path)(struct seq_file *, struct dentry *);
    int (*show_stats)(struct seq_file *, struct dentry *);

    ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
    ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
    struct dquot **(*get_dquots)(struct inode *);

    long (*nr_cached_objects)(struct super_block *,
                            struct shrink_control *);
    long (*free_cached_objects)(struct super_block *,
                            struct shrink_control *);
};
```

This describes how the VFS can manipulate the superblock of the filesystem. **All method are called without any locks being held, unless otherwise noted**. This means that most methods can block safely. All methods are only called from a process context (i.e. not form an interrupt handler or bottom half).
